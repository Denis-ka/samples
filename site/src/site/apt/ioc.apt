 ----
 Инверсия управления
 ----
 Мартин Фоулер
 ----
 2005-06-26

Инверсия управления

  Инверсия управления является распостраненным явлением, с которым вы столкнетесь при использовании фреймворков. И действительно,
  она часто рассматривается как определяющая характеристика фреймворка.

  Давайте рассмотрим простой пример. Представьте себе что я пишу программу, которая получает некоторую информацию от пользователя
  с помощью командной строки. Я мог бы сделать это как-то так:

+----+
  #ruby
  puts 'What is your name?'
  name = gets
  process_name(name)
  puts 'What is your quest?'
  quest = gets
  process_quest(quest)
+----+

  В этой ситуации мой код управляет исполнением: он решает когда задавать вопросы, когда считывать ответы, а когда обрабатывать
  результаты.

  Однако, если бы я использовал оконную систему для чего-то похожего, я написал бы что-то, что настраивает окно:

+----+
  require 'tk'
  root = TkRoot.new()
  name_label = TkLabel.new() {text "What is Your Name?"}
  name_label.pack
  name = TkEntry.new(root).pack
  name.bind("FocusOut") {process_name(name)}
  quest_label = TkLabel.new() {text "What is Your Quest?"}
  quest_label.pack
  quest = TkEntry.new(root).pack
  quest.bind("FocusOut") {process_quest(quest)}
  Tk.mainloop()
+----+

  Теперь в потоке управления между этими двумя программами большая разница - в частности в управлении временем когда вызываются
  методы <<<process_name>>> и <<<process_quest>>>. В примере с коммандной строкой я контролирую когда эти методы вызываются, но в
  примере с оконным приложением нет. Вместо этого я передаю контроль оконной системе (команда <<<Tk.mainloop>>>). Далее она решает
  когда вызвать мои методы, основываясь на связях, которые я настроил при создании формы. Управление инвертировано - управляют
  мной, а не я управляю фреймворком. Это явление и называется инверсией управления (также известно как Принцип Голливуда -
  "Не звони нам, мы сами позвоним тебе").

  <Одной важной характеристикой фреймворка является то, что методы, определенные пользователем для адаптации фреймворка под свои
  нужды, будут чаще всего вызываться внутри самого же фреймворка, а не из кода приложения пользователя. Фреймворк часто играет
  роль главной программы в координации и последовательности активности приложения. Такая инверсия управления дает фреймворку
  возможность служить расширяемым скелетом приложения. Методы, предоставляемые пользователем, адаптируют общие алгоритмы,
  определенные фреймворком, под определенное приложение.>
  <-- Ralph Johnson и Brian Foote>

  Инверсия управления является ключевой частью того, что различает фреймворк и библиотеку. Библиотека это по существу набор
  функций, которые вы можете вызывать, в наши дни они организованы в классы. Каждый вызов выполняет некоторую работу и возвращает
  управление обратно клиенту.

  Фреймворк воплощает в себе некоторый абстрактный дизайн со встроенным поведением. Для того, чтобы использовать его, вы должны
  добавить свой код в различных местах фреймворка, либо через наследование, либо подключив свой собственный класс. Код
  фреймворка впоследствие будет вызывать ваш код.

  There are various ways you can plug your code in to be called. In the ruby example above, we invoke a bind method on the text
  entry field that passes an event name and a {{{http://martinfowler.com/bliki/Closure.html}Closure}} as an argument. Whenever
  the text entry box detects the event, it calls the code in the closure. Using closures like this is very convenient, but many
  languages don't support them.

  Another way to do this is to have the framework define events and have the client code subscribe to these events. .NET is a
  good example of a platform that has language features to allow people to declare events on widgets. You can then bind a method
  to the event by using a delegate.

  The above approaches (they are really the same) work well for single cases, but sometimes you want to combine several required
  method calls in a single unit of extension. In this case the framework can define an interface that a client code must
  implement for the relevant calls.

  EJBs are a good example of this style of inversion of control. When you develop a session bean, you can implement various
  methods that are called by the EJB container at various lifecyle points. For example the Session Bean interface defines
  <<<ejbRemove>>>, <<<ejbPassivate>>> (stored to secondary storage), and <<<ejbActivate>>> (restored from passive state). You
  don't get to control when these methods are called, just what they do. The container calls us, we don't call it.

  These are complicated cases of inversion of control, but you run into this effect in much simpler situations. A template method
  is a good example: the super-class defines the flow of control, subclasses extend this overriding methods or implementing
  abstract methods to do the extension. So in JUnit, the framework code calls <<<setUp>>> and <<<tearDown>>> methods for you to
  create and clean up your text fixture. It does the calling, your code reacts - so again control is inverted.

  There is some confusion these days over the meaning of inversion of control due to the rise of IoC containers; some people
  confuse the general principle here with the specific styles of inversion of control (such as
  {{{http://martinfowler.com/articles/injection.html}dependency injection}}) that these containers use. The name is somewhat
  confusing (and ironic) since IoC containers are generally regarded as a competitor to EJB, yet EJB uses inversion of control
  just as much (if not more).

  <<Etymology>>: As far as I can tell, the term Inversion of Control first came to light in Johnson and Foote's paper
  {{{http://www.laputan.org/drc/drc.html}Designing Reusable Classes}}, published by the Journal of Object-Oriented Programming
  in 1988. The paper is one of those that's aged well - it's well worth a read now over fifteen years later. They think they got
  the term from somewhere else, but can't remember what. The term then insinuated itself into the object-oriented community and
  appears in the Gang of Four book. The more colorful synonym 'Hollywood Principle' seems to originate in a
  {{{http://www.digibarn.com/friends/curbow/star/XDEPaper.pdf}paper by Richard Sweet}} on Mesa in 1983. In a list of design goals
  he writes: "Don't call us, we'll call you (Hollywood's Law): A tool should arrange for Tajo to notify it when the user wishes
  to communicate some event to the tool, rather than adopt an 'ask the user for a command and execute it' model." John Vlissides
  wrote a {{{http://www.research.ibm.com/designpatterns/pubs/ph-feb96.txt}column for C++}} report that provides a good
  explanation of the concept under the 'Hollywood Principle' moniker. (Thanks to Brian Foote and Ralph Johnson for helping me
  with the Etymology.)

